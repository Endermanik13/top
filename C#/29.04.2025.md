# Интерфесы и Перечисления

## Часть 1: Интерфейсы

Интерфейсы в C# задают контракт, который классы должны реализовать, обеспечивая абстракцию и полиморфизм. Они определяют, *что* должен делать класс, но не *как*.

### Что такое интерфейс?

Интерфейс — это шаблон, содержащий сигнатуры методов, свойств или событий, которые класс обязан реализовать. До C# 8.0 интерфейсы не содержали реализаций, но теперь поддерживают методы по умолчанию.

**Зачем нужны интерфейсы?**
- Создают единый контракт для разных классов.
- Поддерживают полиморфизм.
- Упрощают тестирование и замену компонентов.
- Позволяют классу реализовать несколько интерфейсов.

> **Примечание**: Имена интерфейсов по соглашению начинаются с `I` (например, `IMovable`).

### Синтаксис интерфейса

Интерфейс объявляется с ключевым словом `interface`:

```csharp
interface IExample
{
    void SomeMethod();
    string SomeProperty { get; set; }
}
```

Класс, реализующий интерфейс, должен предоставить реализацию всех его членов:

```csharp
class MyClass : IExample
{
    public string SomeProperty { get; set; }
    public void SomeMethod()
    {
        Console.WriteLine("Реализация метода");
    }
}
```

### Возможности интерфейсов

| Элемент | Описание | Пример |
|---------|----------|--------|
| **Методы** | Объявляются без тела, класс их реализует. | `void Move();` |
| **Свойства** | Могут быть `get`, `set` или оба. | `string Name { get; set; }` |
| **Константы** | Неизменяемые значения интерфейса. | `const int minSpeed = 60;` |
| **Статические поля** | Общие данные для интерфейса. | `static int maxSpeed;` |
| **Методы по умолчанию** (C# 8.0+) | Могут содержать реализацию. | `void Move() { ... }` |

### Разбор предоставленного кода

Рассмотрим код, чтобы понять, как работают интерфейсы.

#### Интерфейс `IMovable`

```csharp
interface IMovable
{
    const int minSpeed = 60;
    static int maxSpeed;
    void Move()
    {
        WriteLine("Ваша минимальная скорость: " + minSpeed.ToString());
    }
    string Name { get; set; }
}
```

- **`const int minSpeed`**: Константа, всегда равна 60. Доступна через `IMovable.minSpeed`.
- **`static int maxSpeed`**: Статическое поле, общее для интерфейса, но не инициализировано.
- **`void Move()`**: Метод по умолчанию (C# 8.0+). Выводит минимальную скорость, если класс не переопределит.
- **`string Name { get; set; }`**: Свойство, которое класс должен реализовать.

#### Класс `ShowSpeed`

```csharp
class ShowSpeed : IMovable
{
    public string Name { get; set; } = string.Empty;
    static int maxSpeed = 150;
    public void Move()
    {
        WriteLine("Ваша скорость " + maxSpeed);
    }
}
```

- Реализует `IMovable` через `: IMovable`.
- Свойство `Name` задано с начальным значением `string.Empty`.
- Статическое поле `maxSpeed` равно 150. **Важно**: это поле *не связано* с `maxSpeed` в интерфейсе.
- Метод `Move` переопределяет метод интерфейса, выводя `maxSpeed` класса.

#### Программа

```csharp
internal class Program
{
    static void Main()
    {
        ShowSpeed showSpeed = new ShowSpeed();
        Console.WriteLine(showSpeed.Move);
        Console.WriteLine(IMovable.Move);
    }
}
```

- Создается объект `showSpeed`.
- `Console.WriteLine(showSpeed.Move)`: Выводит сигнатуру метода (`System.Action`), а не его результат.
- `Console.WriteLine(IMovable.Move)`: Аналогично, выводит сигнатуру метода интерфейса.

**Вывод**:
```
System.Action
System.Action
```

> **Особенность**: Код не вызывает методы `Move`, а выводит их как объекты, что, вероятно, не было целью.

### Ключевые моменты

- **Константы и статические поля**: Константы неизменяемы, статические поля изменяемы, но привязаны к типу.
- **Методы по умолчанию**: Позволяют интерфейсам иметь реализацию (C# 8.0+).
- **Полиморфизм**: Интерфейс позволяет работать с объектами через общий контракт.

### Практическое применение

- **Транспорт**: Интерфейс `IMovable` для классов `Car`, `Bicycle`, `Plane`.
- **Плагины**: Интерфейс `IPlugin` с методом `Execute`.
- **Тестирование**: Интерфейс `IDatabase` для подмены базы данных.

---

## Часть 2: Перечисления (enum)

Перечисления (enum) в C# — это тип данных, представляющий набор логически связанных констант. Они упрощают работу с фиксированными наборами значений.

*Последнее обновление материалов: 10.11.2021*

### Что такое перечисление?

Перечисление — это пользовательский тип, который определяет набор именованных констант. Каждая константа связана с целочисленным значением.

**Зачем нужны перечисления?**
- Упрощают чтение кода, заменяя числа именами.
- Ограничивают возможные значения переменной.
- Используются для хранения состояний или типов.

### Синтаксис перечисления

Перечисление объявляется с ключевым словом `enum`:

```csharp
enum DayTime
{
    Morning,
    Afternoon,
    Evening,
    Night
}
```

- После `enum` указывается имя перечисления.
- В фигурных скобках перечисляются константы, разделенные запятыми.
- Каждое перечисление — это новый тип данных.

### Использование перечислений

Перечисления можно использовать для переменных, констант, параметров методов:

```csharp
DayTime dayTime = DayTime.Morning;
const DayTime fixedTime = DayTime.Evening;

if (dayTime == DayTime.Morning)
    Console.WriteLine("Доброе утро");
else
    Console.WriteLine("Привет");
```

### Хранение состояния

Перечисления часто применяются для управления состоянием программы. Пример:

```csharp
DayTime now = DayTime.Evening;

PrintMessage(now); // Добрый вечер
PrintMessage(DayTime.Afternoon); // Добрый день

void PrintMessage(DayTime dayTime)
{
    switch (dayTime)
    {
        case DayTime.Morning:
            Console.WriteLine("Доброе утро");
            break;
        case DayTime.Afternoon:
            Console.WriteLine("Добрый день");
            break;
        case DayTime.Evening:
            Console.WriteLine("Добрый вечер");
            break;
        case DayTime.Night:
            Console.WriteLine("Доброй ночи");
            break;
    }
}

enum DayTime
{
    Morning,
    Afternoon,
    Evening,
    Night
}
```

Здесь метод `PrintMessage` выбирает приветствие в зависимости от значения `DayTime`.

### Пример с арифметическими операциями

Перечисления удобно использовать для выбора операций:

```csharp
DoOperation(10, 5, Operation.Add); // 15
DoOperation(10, 5, Operation.Subtract); // 5
DoOperation(10, 5, Operation.Multiply); // 50
DoOperation(10, 5, Operation.Divide); // 2

void DoOperation(double x, double y, Operation op)
{
    double result = op switch
    {
        Operation.Add => x + y,
        Operation.Subtract => x - y,
        Operation.Multiply => x * y,
        Operation.Divide => x / y
    };
    Console.WriteLine(result);
}

enum Operation
{
    Add,
    Subtract,
    Multiply,
    Divide
}
```

- Перечисление `Operation` задает типы операций.
- Метод `DoOperation` выполняет операцию в зависимости от значения `op`.

### Тип и значения констант

Каждая константа перечисления имеет целочисленное значение. По умолчанию:
- Первый элемент = 0.
- Каждый следующий элемент увеличивается на 1.

Пример:

```csharp
enum DayTime
{
    Morning, // 0
    Afternoon, // 1
    Evening, // 2
    Night // 3
}

DayTime now = DayTime.Morning;
Console.WriteLine((int)now); // 0
Console.WriteLine((int)DayTime.Night); // 3
```

#### Явное указание типа

Тип перечисления можно указать через двоеточие. Допустимые типы: `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`. По умолчанию — `int`.

```csharp
enum Time : byte
{
    Morning, // 0
    Afternoon, // 1
    Evening, // 2
    Night // 3
}
```

#### Явное указание значений

Можно задавать значения констант вручную:

```csharp
enum DayTime
{
    Morning = 3, // 3
    Afternoon, // 4 (автоматически +1)
    Evening, // 5
    Night // 6
}
```

И**или**:

```csharp
enum DayTime
{
    Morning = 2,
    Afternoon = 4,
    Evening = 8,
    Night = 16
}
```

Константы могут иметь одинаковые значения или ссылаться друг на друга:

```csharp
enum DayTime
{
    Morning = 1,
    Afternoon = Morning, // 1
    Evening = 2,
    Night = 2
}
```

> **Ограничение**: Нельзя присваивать числовые значения напрямую (`DayTime now = 2; // Ошибка`).

### Ключевые моменты

- Перечисления — это именованные константы с целочисленными значениями.
- Они ограничивают возможные значения переменной.
- Поддерживают явное указание типа и значений.
- Идеальны для хранения состояний или типов.

### Практическое применение

- **Состояния**: Например, `OrderStatus` (`Pending`, `Shipped`, `Delivered`).
- **Типы операций**: Как в примере с `Operation`.
- **Конфигурации**: Например, `LogLevel` (`Debug`, `Info`, `Error`).

---

## Сравнение интерфейсов и перечислений

| Характеристика | Интерфейсы | Перечисления |
|----------------|------------|--------------|
| **Назначение** | Задают контракт для классов | Определяют набор констант |
| **Содержимое** | Методы, свойства, константы | Именованные константы |
| **Реализация** | Требует реализации в классе | Используется как тип данных |
| **Пример** | `IMovable` для движения | `DayTime` для времени суток |

---

## Советы по использованию

- **Интерфейсы**:
  - Используйте префикс `I` для имен.
  - Делайте интерфейсы узкоспециализированными.
  - Применяйте методы по умолчанию с осторожностью.

- **Перечисления**:
  - Используйте понятные имена констант.
  - Задавайте значения, если порядок или числа важны.
  - Избегайте числовых присваиваний напрямую.

---

## Заключение

Интерфейсы и перечисления — мощные инструменты C# для создания структурированного кода. Интерфейсы обеспечивают абстракцию и полиморфизм, задавая контракт для классов. Перечисления упрощают работу с наборами констант, делая код читаемым и безопасным. Разобранные примеры показали, как использовать эти механизмы, включая особенности методов по умолчанию и числовых значений перечислений.

> **Попробуйте сами**:
> - Создайте интерфейс `IResizable` и реализуйте его в классах `Window` и `Image`.
> - Определите перечисление `OrderStatus` и метод для обработки статусов заказа.
