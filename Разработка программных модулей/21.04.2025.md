# Практическая работа №23: Оптимизация и рефакторинг кода (C++)

## Цели занятия

- Разобраться, что такое **оптимизация** и **рефакторинг** кода.
- Научиться улучшать читаемость, производительность и поддерживаемость кода в C++.
- Практически применить техники рефакторинга и оптимизации в консольном приложении.

---

## Что такое рефакторинг?

Рефакторинг — это улучшение внутренней структуры кода **без изменения его внешнего поведения**. Цель — сделать код понятным, компактным и удобным для дальнейшей разработки.

> "Рефакторинг — это дисциплинированный способ очистки кода, который минимизирует вероятность появления ошибок."\
> — Мартин Фаулер

### Признаки кода, требующего рефакторинга

- **Дублирование кода**: одинаковые куски кода в разных местах.
- **Длинные функции**: функции выполняют слишком много задач.
- **Сложные условия**: громоздкие `if-else` конструкции.
- **Неинформативные имена**: переменные вроде `x`, `temp` или функции вроде `doIt()`.
- **Жёстко закодированные значения**: числа или строки без объяснения (например, `return 42;`).

---

## Что такое оптимизация кода?

Оптимизация — это улучшение **производительности** кода для ускорения работы программы или уменьшения потребления ресурсов (памяти, процессорного времени).

> "Мы должны забыть о небольших улучшениях производительности, скажем, на 97% времени: преждевременная оптимизация — корень всех зол."\
> — Дональд Кнут

**Важно**: Оптимизируйте только после анализа производительности (например, с помощью профилировщиков вроде `gprof` или `Valgrind`).

### Направления оптимизации

1. **Алгоритмическая**: выбор более быстрых алгоритмов (например, замена линейного поиска на бинарный).
2. **Ресурсная**: снижение потребления памяти или процессорного времени.
3. **Кодовая**: устранение лишних операций, упрощение вычислений.

---

## Техники рефакторинга в C++

| **Техника** | **Описание** | **Пример до/после** |
| --- | --- | --- |
| Извлечение функции | Выделение части кода в отдельную функцию. | **До**: длинная функция с дублирующимся кодом.<br>**После**: компактная функция, вызываемая многократно. |
| Улучшение именования | Переименование переменных и функций для ясности. | **До**: `int x;`<br>**После**: `int userAge;` |
| Упрощение условий | Замена сложных условий на более читаемые. | **До**: `if (a > 0 && b < 10 && c)`<br>**После**: `if (isValidInput(a, b, c))` |
| Устранение дублирования | Вынос повторяющегося кода в функцию или класс. | **До**: два похожих цикла.<br>**После**: один общий метод. |

### Пример рефакторинга (C++)

**До рефакторинга**:

```cpp
#include <iostream>
using namespace std;

int main() {
    int a, b;
    cin >> a >> b;
    if (a > 0 && b > 0) {
        int x = a * b;
        cout << "Result: " << x << endl;
    } else {
        cout << "Error" << endl;
    }
    return 0;
}
```

**После рефакторинга**:

```cpp
#include <iostream>
#include <stdexcept>

int calculateArea(int length, int width) {
    if (length <= 0 || width <= 0) {
        throw std::invalid_argument("Length and width must be positive");
    }
    return length * width;
}

int main() {
    try {
        int length, width;
        std::cout << "Enter length and width: ";
        std::cin >> length >> width;
        int area = calculateArea(length, width);
        std::cout << "Area: " << area << std::endl;
    } catch (const std::invalid_argument& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    return 0;
}
```

**Что изменилось**:

- Код разбит на функции с понятными именами.
- Добавлена обработка исключений вместо простого вывода ошибки.
- Проверки вынесены в отдельную функцию.
- Улучшены сообщения для пользователя.

---

## Подходы к оптимизации в C++

1. **Профилирование**:

   - Используйте инструменты вроде `gprof`, `Valgrind` или встроенные профилировщики IDE.
   - Пример: найдите функцию, которая занимает 80% времени выполнения.

2. **Оптимизация алгоритмов**:

   - Линейный поиск: O(n) → Бинарный поиск: O(log n).
   - Использование `std::unordered_map` вместо массива для быстрого поиска.

3. **Кэширование**:

   - Сохраняйте результаты вычислений для повторного использования.
   - Пример: хранение результатов в `std::vector` или `static` переменных.

4. **Уменьшение операций**:

   - Избегайте лишних копирований объектов (используйте ссылки или `std::move`).
   - Заменяйте `std::cout` на `printf` для больших объёмов вывода (если прирост заметен).

### Пример оптимизации (C++)

**До оптимизации**:

```cpp
#include <iostream>
#include <vector>

long long sumSquares(int n) {
    long long result = 0;
    for (int i = 0; i < n; i++) {
        result += i * i;
    }
    return result;
}

int main() {
    int n;
    std::cin >> n;
    std::cout << sumSquares(n) << std::endl;
    return 0;
}
```

**После оптимизации**:

```cpp
#include <iostream>

long long sumSquares(int n) {
    // Используем математическую формулу: сумма квадратов = n(n+1)(2n+1)/6
    return (static_cast<long long>(n) * (n + 1) * (2 * n + 1)) / 6;
}

int main() {
    int n;
    std::cout << "Enter n: ";
    std::cin >> n;
    std::cout << "Sum of squares: " << sumSquares(n) << std::endl;
    return 0;
}
```

**Что изменилось**:

- Заменён цикл на математическую формулу, что снизило сложность с O(n) до O(1).
- Добавлены поясняющие комментарии.
- Улучшен ввод-вывод для пользователя.

---

## Практическое задание

1. Возьмите код консольного приложения из предыдущей лабораторной работы.
2. Найдите **3 проблемы** в коде (например, дублирование, неинформативные имена, сложные условия).
3. Примените **2 техники рефакторинга** (например, извлечение функции, улучшение именования).
4. Проверьте производительность с помощью профилировщика (например, `gprof`).
5. Оптимизируйте **1 участок кода** (например, замените цикл на более эффективный алгоритм).
6. Запишите изменения в отчёт и загрузите на платформу.

**Дедлайн**: до конца сегодняшней пары!

---

## Полезные советы

- **Тестируйте после рефакторинга**: убедитесь, что программа выдаёт тот же результат.
- **Работайте пошагово**: вносите одно изменение за раз.
- **Используйте Git**: сохраняйте версии кода, чтобы избежать потерь.
- **Оптимизируйте с осторожностью**: не жертвуйте читаемостью ради минимального прироста скорости.
- **Используйте** `const` **и ссылки**: это улучшает читаемость и производительность в C++.