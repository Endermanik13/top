name: Update Pages

on:
  push:
    paths:
      - '**/*.md'
  pull_request:
    branches: [main]

jobs:
  update-pages:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'

      - name: Install dependencies
        run: |
          npm install -g @actions/github
          npm install @octokit/rest@18.12.0
          npm install marked
          npm install p-retry
          npm install gray-matter
          npm install markdown-link-check

      - name: Check Markdown links
        run: |
          find . -name "*.md" -exec markdown-link-check {} \;

      - name: Generate pages.json and sitemap.xml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITBOOK_API_TOKEN: ${{ secrets.GITBOOK_API_TOKEN }}
        run: |
          node -e "
            const fs = require('fs');
            const path = require('path');
            const { Octokit } = require('@octokit/rest');
            const pRetry = require('p-retry');
            const matter = require('gray-matter');

            const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

            async function getFileCreationDate(owner, repo, filePath, cache) {
              return pRetry(
                async () => {
                  if (cache[filePath]) return cache[filePath];
                  const commits = await octokit.repos.listCommits({
                    owner,
                    repo,
                    path: filePath,
                    per_page: 1,
                  });
                  const date = commits.data.length > 0 ? commits.data[0].commit.committer.date : new Date().toISOString();
                  cache[filePath] = date;
                  return date;
                },
                { retries: 3, minTimeout: 1000 }
              );
            }

            async function fetchGitBookPages() {
              try {
                const response = await fetch('https://api.gitbook.com/v1/spaces/{spaceId}/content', {
                  headers: { Authorization: 'Bearer ' + process.env.GITBOOK_API_TOKEN },
                });
                if (!response.ok) throw new Error('GitBook API request failed');
                const data = await response.json();
                return data.items.map(item => ({
                  title: item.title,
                  slug: item.slug,
                  description: item.description || item.content.substring(0, 100) + '...',
                  link: item.url,
                  category: item.path.split('/')[1] || 'Разное',
                  content: item.content,
                  date: item.updatedAt,
                  icon: item.icon || 'ri-file-text-line',
                  tags: item.tags || [],
                }));
              } catch (error) {
                console.error('Error fetching GitBook pages:', error.message);
                return [];
              }
            }

            function findMarkdownFiles(dir) {
              let results = [];
              const ignorePatterns = fs.existsSync('.pagesignore') ? fs.readFileSync('.pagesignore', 'utf8').split('\n').filter(Boolean) : [];
              const files = fs.readdirSync(dir, { withFileTypes: true });
              for (const file of files) {
                const fullPath = path.join(dir, file.name);
                if (ignorePatterns.some(pattern => fullPath.includes(pattern))) continue;
                if (file.isDirectory()) {
                  if (file.name === 'node_modules' || file.name.startsWith('.')) continue;
                  results = results.concat(findMarkdownFiles(fullPath));
                } else if (file.name.endsWith('.md')) {
                  results.push(fullPath);
                }
              }
              return results;
            }

            (async () => {
              try {
                let cache = fs.existsSync('file-dates.json') ? JSON.parse(fs.readFileSync('file-dates.json')) : {};
                const files = findMarkdownFiles('.')
                  .filter(filePath => !filePath.includes('Excalidraw') && !/безкатегории/i.test(path.basename(path.dirname(filePath))))
                  .map(filePath => ({
                    name: path.basename(filePath),
                    path: filePath,
                  }));

                const pages = [];
                for (const file of files) {
                  const fileContent = fs.readFileSync(file.path, 'utf8');
                  const { data: frontmatter, content } = matter(fileContent);
                  const slug = file.name.replace('.md', '').toLowerCase().replace(/\s+/g, '-');
                  const date = await getFileCreationDate('Endermanik13', 'top', file.path, cache);
                  const dirName = path.dirname(file.path) === '.' ? 'Разное' : path.basename(path.dirname(file.path));
                  const titleMatch = content.match(/^# (.+)/m);

                  pages.push({
                    title: frontmatter.title || titleMatch?.[1] || file.name.replace('.md', ''),
                    slug,
                    description: frontmatter.description || content.split('\n').slice(1).join(' ').substring(0, 100) + '...',
                    link: 'https://endermanik13.github.io/top/page/' + slug,
                    category: frontmatter.category || dirName,
                    content,
                    date,
                    icon: frontmatter.icon || 'ri-file-text-line',
                    tags: frontmatter.tags || [],
                  });
                }

                const gitbookPages = await fetchGitBookPages();
                const allPages = [...pages, ...gitbookPages];
                allPages.sort((a, b) => new Date(b.date) - new Date(a.date));

                // Generate pages.json
                fs.writeFileSync('pages.json', JSON.stringify(allPages, null, 2));
                fs.writeFileSync('file-dates.json', JSON.stringify(cache, null, 2));

                // Generate sitemap.xml
                const sitemap = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>
                <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">
                  ${allPages.map(page => `
                    <url>
                      <loc>https://endermanik13.github.io/top/#${page.slug}</loc>
                      <lastmod>${page.date}</lastmod>
                    </url>
                  `).join('')}
                </urlset>`;
                fs.writeFileSync('sitemap.xml', sitemap);

                console.log('Generated pages.json with', allPages.length, 'pages');
              } catch (error) {
                console.error('Error in script:', error.message);
                process.exit(1);
              }
            })();
          "

      - name: Commit and push changes
        run: |
          git config --global user.name 'GitHub Action'
          git config --global user.email 'action@github.com'
          git add pages.json file-dates.json sitemap.xml
          git commit -m "Update pages.json, file-dates.json, and sitemap.xml" || echo "No changes to commit"
          git push

      - name: Clear GitHub Pages cache
        if: github.event_name == 'push'
        run: |
          curl -X POST \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/Endermanik13/top/pages/builds

      - name: Notify Telegram on Success
        if: success()
        run: |
          curl -s -X POST https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage \
            -d chat_id=${{ secrets.TELEGRAM_CHAT_ID }} \
            -d text="✅ Pages.json updated successfully!"
      - name: Notify Telegram on Failure
        if: failure()
        run: |
          curl -s -X POST https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage \
            -d chat_id=${{ secrets.TELEGRAM_CHAT_ID }} \
            -d text="❌ Failed to update pages.json: ${{ github.sha }}"
